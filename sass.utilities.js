/* eslint-disable */

const sass = require('sass');
const fs = require('fs');
const path = require('path');

const packageDetails = require('./package.json');

const packageVersion = packageDetails.version;

const DIST_DIRECTORY = './dist';
const SASS_SRC_DIRECTORY = './src/styles';
const ICON_FONTS_SRC_DIRECTORY = './src/icons/fonts';
const STATIC_SRC_DIRECTORY = './src/staticAssets';
const AUTOGEN_DIRECTORY = './src/autoGenerated';

function createThemeJson(availableThemes) {
  fs.writeFileSync(path.join(AUTOGEN_DIRECTORY, 'libraryThemes.json'), JSON.stringify(availableThemes, null, 2));
}

function createSemVersionThemeJson(availableThemes) {
  const semVersionAvailableThemes = Object.entries(JSON.parse(availableThemes)).reduce((acc, [key, value]) => {
    acc[key] = {
      ...value,
      versioned: {
        css: `${key}.min.${packageVersion}.css`,
        map: `${key}.min.${packageVersion}.css.map`,
      },
    };
    return acc;
  }, {});
  fs.writeFileSync(
    path.join(AUTOGEN_DIRECTORY, 'libraryThemes.json'),
    JSON.stringify(semVersionAvailableThemes, null, 2),
  );
}

function copyStaticFiles() {
  fs.cpSync(ICON_FONTS_SRC_DIRECTORY, path.join(DIST_DIRECTORY, 'styles/themes/icons/fonts'), { recursive: true });
  fs.cpSync(STATIC_SRC_DIRECTORY, path.join(DIST_DIRECTORY, 'styles/themes/staticAssets'), { recursive: true });
}

function findSassFiles(dir) {
  let results = [];
  const list = fs.readdirSync(dir);
  list.forEach(file => {
    const filePath = path.join(dir, file);
    const stat = fs.statSync(filePath);
    if (stat && stat.isDirectory()) {
      results = results.concat(findSassFiles(filePath));
    } else if (file === 'index.scss') {
      results.push(filePath);
    }
  });
  return results;
}

function buildSassFiles() {
  const availableThemes = {};
  const sassFiles = findSassFiles(SASS_SRC_DIRECTORY);

  sassFiles.forEach(scssPath => {
    const distFolder = path.dirname(scssPath).substring(4);
    const destDir = path.join(DIST_DIRECTORY, distFolder);

    function extractThemeName(filePath) {
      const themeRegex = /\/themes\/([^/]+)\//;
      const match = filePath.match(themeRegex);
      const themeName = match ? match[1] : 'index';
      const themeFileNames = {
        buildPath: distFolder,
        dev: {
          css: `${themeName}.css`,
          map: `${themeName}.css.map`,
        },
        min: {
          css: `${themeName}.min.css`,
          map: `${themeName}.min.css.map`,
        },
        versioned: {
          css: `${themeName}.min.${packageVersion}.css`,
          map: `${themeName}.min.${packageVersion}.css.map`,
        },
      };

      if (match) {
        availableThemes[match[1]] = themeFileNames;
      }
      return themeFileNames;
    }

    const { dev, min, versioned } = extractThemeName(scssPath);

    fs.mkdirSync(destDir, { recursive: true });

    try {
      const devResults = sass.compile(scssPath, {
        style: 'expanded',
        sourceMap: true,
        silenceDeprecations: ['legacy-js-api'],
        loadPaths: [path.join(__dirname, 'styles/shared/partials')],
      });
      fs.writeFileSync(path.join(destDir, dev.css), devResults.css);
      if (devResults.sourceMap) {
        fs.writeFileSync(path.join(destDir, dev.map), JSON.stringify(devResults.sourceMap));
      }

      const prodResults = sass.compile(scssPath, {
        style: 'compressed',
        sourceMap: true,
        silenceDeprecations: ['legacy-js-api'],
        loadPaths: [path.join(__dirname, 'styles/shared/partials')],
      });
      fs.writeFileSync(path.join(destDir, min.css), prodResults.css);
      if (prodResults.sourceMap) {
        fs.writeFileSync(path.join(destDir, versioned.css), JSON.stringify(prodResults.sourceMap));
        fs.writeFileSync(path.join(destDir, versioned.map), JSON.stringify(prodResults.sourceMap));
      }
    } catch (error) {
      console.error('Error during Sass compilation:', error);
      process.exit(1); // Exit with error code to trigger nodemon restart
    }
  });

  createThemeJson(availableThemes);
  copyStaticFiles();
  // return JSON.stringify(availableThemes, null, 2);

  return;
}

// Export the build function for use in nodemon
module.exports = {
  buildSassFiles,
  createThemeJson,
  createSemVersionThemeJson,
};

// Run the build function when this file is executed directly
if (require.main === module) {
  buildSassFiles();
}
